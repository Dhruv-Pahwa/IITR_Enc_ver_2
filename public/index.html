<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>AES Stream Portal (Demo)</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
<div class="container">
  <h1>AES Stream Portal — Demo</h1>

  <div class="controls">
    <div>
      <label>Upload file (server encrypt & broadcast):</label><br/>
      <input id="fileInput" type="file"/>
      <button id="uploadBtn">Encrypt & Broadcast</button>
    </div>

    <div style="margin-top:12px;">
      <label>Real-time streaming (client-side encrypt):</label><br/>
      <button id="startStreamBtn">Start Streaming</button>
      <button id="stopStreamBtn">Stop / Export CSV</button>
      <label>Interval ms:</label>
      <input id="intervalMs" type="number" value="1000" style="width:80px"/>
    </div>
  </div>

  <h2>Encryption → Decryption View (Client Side)</h2>
  <div id="cryptoView" style="background:#020617;padding:12px;border-radius:8px;">
    <strong style="color:#38bdf8;">Encrypted (Ciphertext Preview)</strong>
    <pre id="encryptedPreview" style="color:#facc15;"></pre>

    <strong style="color:#22c55e;">Decrypted (Original Data)</strong>
    <pre id="decryptedPreview" style="color:#a7f3d0;"></pre>
  </div>

  <h2>Live Logs</h2>
  <div id="logs" class="logs"></div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
/* =============================
   BASIC SETUP
============================= */
const socket = io();
const logs = document.getElementById("logs");

function addLog(msg,color="white"){
  const d=document.createElement("div");
  d.style.color=color;
  d.innerHTML=`[${new Date().toLocaleTimeString()}] ${msg}`;
  logs.appendChild(d);
  logs.scrollTop=logs.scrollHeight;
}

/* =============================
   LOAD DEMO AES KEY
============================= */
let AES_KEY=null;

async function loadKey(){
  const r=await fetch("/get_key");
  const j=await r.json();
  const raw=Uint8Array.from(atob(j.key_base64),c=>c.charCodeAt(0));
  AES_KEY=await crypto.subtle.importKey(
    "raw",raw.buffer,{name:"AES-GCM"},false,["encrypt","decrypt"]
  );
  addLog("Imported demo AES key from server.","lime");
}
loadKey();

/* =============================
   UTILS
============================= */
function randIV(){
  const iv=new Uint8Array(12);
  crypto.getRandomValues(iv);
  return iv;
}
function bufToB64(buf){
  return btoa(String.fromCharCode(...new Uint8Array(buf)));
}
function bufToHex(buf){
  return Array.from(new Uint8Array(buf))
    .map(b=>b.toString(16).padStart(2,"0")).join("");
}
function hexToUint8(hex){
  const a=new Uint8Array(hex.length/2);
  for(let i=0;i<hex.length;i+=2)
    a[i/2]=parseInt(hex.substr(i,2),16);
  return a;
}

/* =============================
   FILE UPLOAD (SERVER)
============================= */
document.getElementById("uploadBtn").onclick=async()=>{
  const f=document.getElementById("fileInput").files[0];
  if(!f) return alert("Choose file");
  const arr=await f.arrayBuffer();
  const b64=bufToB64(arr);

  addLog("Uploading file for encryption & broadcast…","cyan");
  await fetch("/upload-and-broadcast",{
    method:"POST",
    headers:{"Content-Type":"application/json"},
    body:JSON.stringify({
      filename:f.name,
      filetype:f.type||"application/octet-stream",
      filedata:b64
    })
  });
};

/* =============================
   STREAMING
============================= */
let streamTimer=null;
let decryptedDataBuffer=[];

async function encryptChunk(bytes){
  const iv=randIV();
  const ct=await crypto.subtle.encrypt(
    {name:"AES-GCM",iv},AES_KEY,bytes
  );
  return {iv:bufToHex(iv.buffer),ciphertext:bufToB64(ct)};
}

/* RECEIVER: decrypt + buffer */
socket.on("stream_chunk",async(data)=>{
  addLog("Encrypted stream chunk received","yellow");

  document.getElementById("encryptedPreview").textContent=
    data.ciphertext.substring(0,120)+"...";

  try{
    const iv=hexToUint8(data.iv);
    const ct=Uint8Array.from(atob(data.ciphertext),c=>c.charCodeAt(0));
    const plain=await crypto.subtle.decrypt(
      {name:"AES-GCM",iv},AES_KEY,ct
    );
    const txt=new TextDecoder().decode(plain);

    document.getElementById("decryptedPreview").textContent=txt;

    try{
      decryptedDataBuffer.push(JSON.parse(txt));
      addLog("Buffered rows: "+decryptedDataBuffer.length,"orange");
    }catch{}
  }catch(e){
    addLog("Decrypt error: "+e.message,"red");
  }
});

/* SENDER */
document.getElementById("startStreamBtn").onclick=()=>{
  decryptedDataBuffer=[];
  let i=0;
  const ms=parseInt(intervalMs.value)||1000;

  streamTimer=setInterval(async()=>{
    const sample={
      timestamp:new Date().toISOString(),
      value:Math.random(),
      seq:i++
    };
    const bytes=new TextEncoder().encode(JSON.stringify(sample));
    const enc=await encryptChunk(bytes);
    socket.emit("stream_chunk",enc);
    addLog("Sent encrypted chunk seq="+sample.seq,"cyan");
  },ms);
};

/* =============================
   STOP / EXPORT (FIXED)
============================= */
function exportCSV(data){
  if(!data.length){
    addLog("No decrypted data to export","red");
    return;
  }
  const headers=Object.keys(data[0]);
  const rows=data.map(r=>headers.map(h=>r[h]).join(","));
  const csv=headers.join(",")+"\n"+rows.join("\n");

  const blob=new Blob([csv],{type:"text/csv"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url;
  a.download="decrypted_stream_"+Date.now()+".csv";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

document.getElementById("stopStreamBtn").onclick=()=>{
  if(streamTimer){
    clearInterval(streamTimer);
    streamTimer=null;
    addLog("Streaming stopped (sender).","gray");
  }

  if(decryptedDataBuffer.length){
    addLog("Exporting decrypted CSV…","yellow");
    exportCSV(decryptedDataBuffer);
    decryptedDataBuffer=[];
  }else{
    addLog("No decrypted data available.","red");
  }
};
</script>
</body>
</html>
